# lab7 Report  计21 王振 2012011397

## [练习0] 填写已有实验

## [练习1] 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

##给出内核级信号量的设计描述，并说其大致执行流程
> 本实验的信号量实现建立在开关中断机制和wait queue的基础上。信号量的数据结构定义如下：
```
    typedef struct {
        int value;                           //信号量的当前值
        wait_queue_t wait_queue;             //信号量对应的等待队列
    } semaphore_t;
```
semaphore_t是最基本的记录型信号量（record semaphore)结构，包含了用于计数的整数值value，和一个进程等待队列wait_queue，一个等待的进程会挂在此等待队列上。</br>
在ucore中最重要的信号量操作是P操作函数down(semaphore_t *sem)和V操作函数 up(semaphore_t *sem)。但这两个函数的具体实现是__down(semaphore_t *sem, uint32_t wait_state) 函数和__up(semaphore_t *sem, uint32_t wait_state)函数

##给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。
> 在用户态进程/线程里实现信号量机制，可以用软件的方法实现信号量，也可以由内核提供原子操作使得检查内存、修改并写回的过程不被打断，用户态通过调用原子操作保证只有一个进程/线程处于临界区，进而实现信号量机制。
在用户态实现信号量主要采用软件的方法，而内核级信号量由于在内核中控制，可以直接屏蔽中断以及进行进程的状态变化，因而内核中实现信号量更为方便。但是由于屏蔽中断对于多处理器没有作用，所以在多处理器中内核级信号量实现不能采用开关中断的方法,此时可以考虑通过锁住总线，来实现屏蔽互斥。也可以使用原子操作。
尽管实现方法有所不同，但二者的信号量数据结构以及在P操作和V操作功能上都是一致的。

## [练习2] 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题
>给出内核级条件变量的设计描述，并说其大致执行流程
> 

condvar_t定义如下：
```
    typedef struct condvar{
        semaphore_t sem; // the sem semaphore is used to down the waiting proc, and the signaling proc should up the waiting proc
        int count;       // the number of waiters on condvar
        monitor_t * owner; // the owner(monitor) of this condvar
    } condvar_t;
```
条件变量的定义中也包含了一系列的成员变量，信号量sem用于让发出wait_cv操作的等待某个条件C为真的进程睡眠，而让发出signal_cv操作的进程通过这个sem来唤醒睡眠的进程。count表示等在这个条件变量上的睡眠进程的个数。owner表示此条件变量的宿主是哪个管程。</br>
这里,条件变量两个主要操作wait_cv和signal_cv分别实现为cond_wait和cond_signal函数，此外还有cond_init初始化函数。以下，是cond_wait和cond_signal的实现原理：</br>
cond_wait的原理描述
```
cv.count++;
if(monitor.next_count > 0)
   sem_signal(monitor.next);
else
   sem_signal(monitor.mutex);
sem_wait(cv.sem);
cv.count -- ;
```
cond_signal的原理描述
```
if( cv.count > 0) {
   monitor.next_count ++;
   sem_signal(cv.sem);
   sem_wait(monitor.next);
   monitor.next_count -- ;
}
```
在管程中的每个函数的入口和出口增加相关操作：
```
function （…）
{
sem.wait(monitor.mutex);
  the real body of function;
  if(monitor.next_count > 0)
     sem_signal(monitor.next);
  else
     sem_signal(monitor.mutex);
}
```

思考题,给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同
> 在用户态进程/线程提供条件变量机制，由于条件变量基于信号量的实现，因此首先要提供在用户态的信号量机制，然后基于此实现条件变量。所以主要还是信号量的设计，假定信号量机制已经在用户态提供了，那么条件变量的实现和在内核态实现没有区别。
用户态的条件变量机制和在内核态实现除了基于的信号量实现不同外，其他的上层操作应该都是一致的。

## 原理知识
> 同步互斥的实现方法:硬件实现, 软件方法实现, 信号量实现, 管程实现.   
2.内核级信号量的实现   
3.内核级条件变量的实现  
4.运用信号量, 管程来解决哲学家就餐问题.  

## 列出你认为OS原理中很重要，但在实验中没有对应上的知识点
> 解决临界区访问的软件方法没有涉及。
